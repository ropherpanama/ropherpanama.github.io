<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | El blog del xobi]]></title>
  <link href="http://ropherpanama.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://ropherpanama.github.io/"/>
  <updated>2015-09-29T23:37:39-05:00</updated>
  <id>http://ropherpanama.github.io/</id>
  <author>
    <name><![CDATA[Rosendo Peña Hernández]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android Unable to Execute Dex: Multiple Dex Files]]></title>
    <link href="http://ropherpanama.github.io/blog/2015/09/29/android-dex-multiple-libs/"/>
    <updated>2015-09-29T11:38:22-05:00</updated>
    <id>http://ropherpanama.github.io/blog/2015/09/29/android-dex-multiple-libs</id>
    <content type="html"><![CDATA[<p>Este problema es bastante sencillo de solucionar, sólo hay que LEER (lo entendí después de una noche rompiendome la cabeza) en vez de GOOGLEAR.</p>

<p><strong>En mi caso el mensaje era este:</strong></p>

<blockquote><p>[2013-05-07 23:08:21 - Dex Loader] Unable to execute dex: Multiple dex files define Lcom/sun/jersey/api/json/JSONConfigurated;
[2013-05-07 23:08:21 - smf-prototype] Conversion to Dalvik format failed: Unable to execute dex: Multiple dex files define Lcom/sun/jersey/api/json/JSONConfigurated;</p></blockquote>

<p>Estoy trabajando en unos <strong>webservices</strong> que usan el soporte de <strong>JSON</strong> y para eso requiero un par de librerías.</p>

<!--more-->


<p></p>

<p>La clave está precisamente en el mensaje :</p>

<blockquote><p>com/sun/jersey/api/json/JSONConfigurated</p></blockquote>

<p>Al buscar entre las librerías que estaba usando para los asuntos de <strong>JSON</strong> (<code>jersey-json-1.16.jar</code> y <code>jersey-bundle-1.17.jar</code>) me dí cuenta que ambos JARs tienen la clase <code>JSONConfigurated</code> ubicada en el mismo paquete.</p>

<p><img src="http://1.bp.blogspot.com/-e_SS03hFSSw/UYpjIpX6A1I/AAAAAAAAAD0/BVAwux4Dfp4/s1600/json+1.png" alt="enter image description here" /></p>

<p><img src="http://3.bp.blogspot.com/-5to6ccF1tbk/UYpjlQhgYwI/AAAAAAAAAD8/GQu0Dwe-ABo/s1600/json+2.png" alt="enter image description here" /></p>

<p><strong>Solución</strong> : eliminar una de las librerías o usar un <code>bundle</code>, como en mi caso. En realidad sin saber había metido la otra librería (<code>jersey-json</code>) y por eso me tiraba el error, pero he visto en muchos lados que a la gente les pasa lo mismo con otras librerías.
Algunos borran las <strong>Dependencias de Android</strong> del <strong>build path</strong> (funciona pero si usas cosas como <strong>anotaciones de Android</strong> no es nada agradable), otros le hacen un simple <strong>Clean</strong> al proyecto, pero realmente el problema es este, debemos tener cuidado y control de las librerías que estamos incluyendo en nuestro proyecto, debemos fijarnos bien si las versiones que usamos son compatibles entre sí.</p>

<p>Un saludo!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android: Verificar Estado Del WIFI]]></title>
    <link href="http://ropherpanama.github.io/blog/2015/09/29/android-estado-del-apaptador-wifi/"/>
    <updated>2015-09-29T11:35:21-05:00</updated>
    <id>http://ropherpanama.github.io/blog/2015/09/29/android-estado-del-apaptador-wifi</id>
    <content type="html"><![CDATA[<p>Este es un tipo de funcionalidad que es bueno tenerla en una clase de utilidades globales (en otras palabras, en una clase de métodos estáticos).</p>

<p>Aveces es necesario conocer el estado del adaptador de red WIFI, para permitirle al usuario o a la misma aplicación realizar o no un proceso crítico del flujo de ejecución.</p>

<p>Como lo escribí arriba, hagamos una <strong>clase de utilidades</strong>, como la siguiente:</p>

<!--more-->


<pre><code>import android.content.Context;

public class SystemUtils {    
    public static boolean isWifiOn(Context context) {
        ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
        NetworkInfo ni = cm.getNetworkInfo(ConnectivityManager.TYPE_WIFI);

        if(!ni.isConnected()) return false; else return true;
    }
} 
</code></pre>

<p>Nuestro método <code>isWifiOn</code> nos retornará un <code>true</code> si el WIFI está encendido; un <code>false</code> en caso contrario. Lo que nos permite implementar una acción dependiendo del caso en el que sea llamada la función, por ejemplo:</p>

<pre><code>if(SystemUtils.isWifiOn(getApplicationContext()))
    Toast.makeText(getApplicationContext(), "WIFI está encendido", Toast.LENGTH_LONG).show(); 
else
    Toast.makeText(getApplicationContext(), "WIFI está apagado", Toast.LENGTH_LONG).show();
</code></pre>

<p>Noten que al ser un <strong>método estático</strong> lo podemos llamar sin instanciar la clase <code>SystemUtils</code>; pues lo podemos acceder mediante un llamado directo.</p>

<p>Otro punto muy importante, antes de ejecutar tu aplicación asegurate de que en el <strong>AndroidManifest.xml</strong> le estás cediendo los <strong>permisos</strong> a la aplicación para que pueda verificar el estado del adaptador.</p>

<pre><code>&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/&gt; 
</code></pre>

<p>Espero les sirva, saludos!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android, ListView Dentro De Un ScrollView]]></title>
    <link href="http://ropherpanama.github.io/blog/2015/09/29/android-scrollview/"/>
    <updated>2015-09-29T11:32:20-05:00</updated>
    <id>http://ropherpanama.github.io/blog/2015/09/29/android-scrollview</id>
    <content type="html"><![CDATA[<p>Aveces, cuando desarrollas <strong>antes de leer las teorías</strong> pasan cosas como esta.
Hace algunos días, me encontré con una dificultad al desarrollar una aplicación Android; mi caso era el siguiente.
Quería que una de las pantallas de mi aplicación respondiera a los cambios de orientación que el usuario realizara a su teléfono, esto no es mayor problema, por defecto el <strong>manifest</strong> de la aplicación configura todas las actividades para que esto suceda. Mi problema era que en esa pantalla tenia un <code>ListView</code> que desplegaba una lista de productos. En modo vertical se veía perfecto el <code>ListView</code>, pero al girar el teléfono; al ser el espacio vertical más pequeño, no mostraba todos los componentes de la lista, porque quedaban escondidos al girar la pantalla.</p>

<!--more-->


<p><strong>La solución:</strong> Utilizar, en lugar de un <code>&lt;LinearLayout/&gt;</code> un <code>&lt;ScrollView /&gt;</code>, el problema:</p>

<blockquote><p><strong>NO SE PUEDE TENER UN LISTVIEW DENTRO DE UN SCROLLVIEW.</strong></p></blockquote>

<p>Bueno &hellip; con un pequeño truco si se puede, veamos:</p>

<p><strong>Mi actividad era algo así</strong></p>

<p><img src="http://4.bp.blogspot.com/-96MFYd6nWyk/UyvLJ4L7_QI/AAAAAAAAAIE/HwifvWIuSf4/s1600/cap1.PNG" alt="enter image description here" /></p>

<p>En lugar de tenerlo todo en un <code>LinearLayout</code>, debemos tener todo en un <code>ScrollView</code>, para que al girar el dispositivo podamos &ldquo;scrollear&rdquo; y poder ver todos los componentes de la GUI de la app.</p>

<p>Primero debemos crear nuestra propia clase que extienda de <code>ScrollView</code></p>

<pre><code>package com.example.layout.modified;

import android.content.Context;
import android.util.AttributeSet;
import android.view.MotionEvent;
import android.widget.ScrollView;

public class VerticalScrollView extends ScrollView {

  public VerticalScrollView(Context context) {
  super(context);
 }

  public VerticalScrollView(Context context, AttributeSet attrs) {
  super(context, attrs);
 }

  public VerticalScrollView(Context context, AttributeSet attrs, int defStyle) {
  super(context, attrs, defStyle);
 }

  @Override
 public boolean onInterceptTouchEvent(MotionEvent ev) {
  final int action = ev.getAction();
  switch (action) {
  case MotionEvent.ACTION_DOWN:
   super.onTouchEvent(ev);
   break;

   case MotionEvent.ACTION_MOVE:
   return false; // redirect MotionEvents to ourself

   case MotionEvent.ACTION_CANCEL:
   super.onTouchEvent(ev);
   break;

   case MotionEvent.ACTION_UP:
   return false;

   default:
   break;
  }

   return false;
 }

  @Override
 public boolean onTouchEvent(MotionEvent ev) {
  super.onTouchEvent(ev);
  return true;
 }
}
</code></pre>

<p>Con esta clase reescribimos el comportamiento de un <code>ScrollView</code> normal, y esto nos evitará el mal funcionamiento de nuestra app al querer hacer scroll sobre la pantalla. Tal cual como esta allí pueden copiarla.
El siguiente paso será utilizar en nuestro <strong>xml</strong> de la actividad nuestra Custom Class, así:</p>

<p><img src="http://4.bp.blogspot.com/-3Gpr-xXwfko/UyvLmlj0FqI/AAAAAAAAAIM/ryRFTeXkw5Q/s1600/cap2.PNG" alt="enter image description here" /></p>

<p>Observar el inicio del tag del <strong>xml</strong> ahora, <code>&lt;com.example.layout.modified.VerticalScrollView</code>, observar que es muy importante nombrar completamente la clase (nombre de paquete y nombre de clase) ,con esto estamos indicando que queremos usar nuestro <strong>custom ScrollView</strong> llamado <code>VerticalScrollView</code>, lo segundo es que he colocado el contenido de mi actividad dentro del nuevo <code>ScrollView</code>.</p>

<p>Con esto ya tendremos solucionado nuestro pequeño inconveniente y podremos Scrollear sobre un <code>ScrollView</code> que contiene un <code>ListView</code>.</p>

<p>Dudas a la orden, Saludos!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introducción a Android Con Un Ejemplo (Y No Es HelloWorld)]]></title>
    <link href="http://ropherpanama.github.io/blog/2015/09/29/android-primer-ejemplo/"/>
    <updated>2015-09-29T11:27:28-05:00</updated>
    <id>http://ropherpanama.github.io/blog/2015/09/29/android-primer-ejemplo</id>
    <content type="html"><![CDATA[<p>Esta introducción va a ser diferente, ya que no vamos a ver como instalar ni configurar el SDK o cosas por el estilo y vamos a pasar directo a ver como luce un proyecto de android una vez creado. Además vamos a aplicar algo de programación para hacer una ventana que haga algo más que el clásico HelloWorld.</p>

<p>Primero vamos a crear un nuevo proyecto de Android: <strong>File -> New -> Android Application Project</strong> (o sus similares en español).</p>

<p>Completa los datos como los ves en la siguiente imagen, los detalles de SDK van a depender de lo que tengas instalado en tu máquina, por lo general suelo definir como SDK mínimo el 2.3, para lo demás uso lo más reciente disponible que tenga; en mi caso el Target lo he colocado API 18 y compilaré
con el API 19</p>

<!--more-->


<p><img src="http://4.bp.blogspot.com/-_4-FO8OZOYc/UzMj5-hW6KI/AAAAAAAAAIg/2uUpH37maNY/s1600/button_events_8.PNG" alt="enter image description here" /></p>

<p>Paso seguido vamos a asegurarnos de marcar las casillas que aparecen en la siguiente imagen:</p>

<p><img src="http://1.bp.blogspot.com/-lmkUUXZtaGs/UzMlcdv--JI/AAAAAAAAAJk/zbGNW0bP46M/s1600/button_events_9.PNG" alt="enter image description here" /></p>

<p>Desmarco <strong>&ldquo;Create custom launcher icon&rdquo;</strong> porque no me interesa ahora mismo crear un icono para la app.
Dejo marcada <strong>&ldquo;Create activity&rdquo;</strong> porque quiero que me genere y me configure una primera actividad (Pantalla y su controlador) que será la que editaremos más adelante. Presionamos Next</p>

<p><img src="http://3.bp.blogspot.com/-kipzblDykgY/UzMlcQzaynI/AAAAAAAAAJ4/qfYQUVlf2cU/s1600/button_events_10.PNG" alt="enter image description here" /></p>

<p>Como decidimos crear una <strong>Activity</strong> nos aparece esta pantalla, asegúrate de configurarla como en la imagen y presiona Next. En la pantalla siguiente colócale un nombre a tu activity (Activity Name), lo demás se autocompleta según lo que coloques. Presiona Finish.</p>

<p><img src="http://1.bp.blogspot.com/-S2ciCbhk_DU/UzMlcbf7flI/AAAAAAAAAJ0/Aas-vdl2PJI/s1600/button_events_11.PNG" alt="enter image description here" /></p>

<p>Después de seguidos estos pasos debes tener una estructura de proyecto como la siguiente:</p>

<p><img src="http://2.bp.blogspot.com/-KIEJi-lTiRA/UzMj8Bw0pCI/AAAAAAAAAI8/_nnl6I874hE/s1600/button_events_3.PNG" alt="enter image description here" /></p>

<p>Primero vamos a darle un vistazo al archivo llamado <strong>AndroidManifest.xml</strong></p>

<p>Hay muchas cosas que no sabrás con qué se comen, pero por ahora lo que nos interesa conocer es lo siguiente:
1.  <strong>Linea 4:</strong> es la versión de nuestra app, la podremos ir aumentando según vaya creciendo nuestra app (nuevas versiones)
2.  <strong>Lineas 13,14 y 15:</strong> Si te fijas verás que la referencia a los componentes están precedidos por un <strong>@</strong>, esto significa que son recursos de tu aplicación, estos recursos pueden ser manipulados libremente por tí para personalizar tu app a tu gusto. Dáles un vistazo presionando la tecla <strong>Ctrl + Click</strong> sobre el <strong>@</strong> de cada uno.
3.  <strong>Linea 17:</strong> De esta forma se asocia la activity (XML) con tu código Java, ves que el <strong>name del activity</strong> es el mismo de la clase que se creó en el <strong>package</strong> que definimos (es su nombre completo <strong>package + class name</strong>)
4.  <strong>Linea 19:</strong> El <code>&lt;intent-filter&gt;</code>  en este caso está indicando que nuestra única activity que tenemos, será la primera en aparecer cuando ejecutemos nuestra aplicación, esto se logra con las lineas <strong>20</strong> y <strong>22</strong>.</p>

<p><img src="http://2.bp.blogspot.com/-RIoA1LMP-RM/UzMoR3HNGnI/AAAAAAAAAKE/4EcrxOlhuXw/s1600/button_events_6.PNG" alt="enter image description here" /></p>

<p>Ahora vamos a editar los ficheros <strong>activity_button_event.xml</strong> (archivo en donde se diseña la pantalla) y su controlador <code>ButtonEventActivity.java</code> (Que vendría siendo algo asi como el <code>Listener</code> del <code>JFrame</code> en <code>Swing</code>)</p>

<p>Primero editamos el xml para que en vez de un <code>TextView</code> (algo así como el <code>JLabel</code> de <code>Swing</code>) nos muestre un <code>Button</code> (algo así como el <code>JButton</code> de <code>Swing</code>), lo haremos de esta forma:</p>

<p><img src="http://3.bp.blogspot.com/-P74H8F4n6FY/UzMoR16fKEI/AAAAAAAAAKM/k4jQDWZWqjU/s1600/button_events_4.PNG" alt="enter image description here" /></p>

<p>Primero, hemos reemplazado el <strong>Layout</strong> (similar a como se aplican layouts en <code>Swing</code>) default por un <code>LinearLayout</code>, en la <strong>linea 5</strong> vemos que la orientación es <strong>vertical</strong>, esto quiere decir que todos los componentes que vayamos agregando se irán apilando <strong>uno debajo del otro</strong>.
En la <strong>línea 12</strong> estamos creando un <code>Button</code>, con su etiqueta o texto (Ver mensaje) y sus propiedades de tamaño, <strong>fill_parent</strong> le indica al componente que debe extenderse tanto como el tamaño de su contenedor y <strong>wrap_content</strong> le indica al componente que debe ajustarse al contenido que tenga el componente, en este caso es un texto, así que se ajustará al texto para extenderse.
En la <strong>linea 16</strong> se muestra la forma que ofrece <strong>Android</strong> para manipular los eventos de los botones (es muy sencilla y practica aunque no es la única forma), si venimos programando con <strong>java SE</strong> podremos aplicar los mismos mecanismos de manejo de eventos (<code>addActionListener</code> .. etc.).</p>

<h3>¿Cómo funciona esto?</h3>

<p>Al definir en el <code>onClick</code> la etiqueta &ldquo;<code>ejecutarEvento</code>&rdquo;, debemos crear en el controlador de la pantalla (archivo <strong>.java</strong>) una función sin retorno (<strong>void</strong>) con el mismo nombre de esa etiqueta y que reciba como parámetro un <strong>View</strong>, así de sencillo.</p>

<p>Veamos el código del controlador:</p>

<p><img src="http://3.bp.blogspot.com/-MzLU7JGUS9k/UzMoR_kp9DI/AAAAAAAAAKY/QSTIGgZ06yI/s1600/button_events_5.PNG" alt="enter image description here" /></p>

<p>Las primeras 24 lineas te las debe generar el <strong>Eclipse</strong> cuando creamos el proyecto, lo nuevo y lo que debemos añadir nosotros son las <strong>líneas 29 en adelante</strong> (sin olvidar escribir los javadocs, créanme que son muy útiles para quienes tengan que revisar su código posteriormente). Como se dijo, el nombre del método es el mismo al que tiene el <code>Button</code> en el <code>onClick</code> en el XML anterior y lleva un <code>View</code> como argumento.
Lo que hace nuestro botón es mostrarnos un <code>Toast</code> (un pequeño aviso en pantalla) indicando que se ha realizado un click en el botón.</p>

<p>Ahora puedes proceder a ejecutar tu aplicación, en la medida de lo posible usar un teléfono real, ya que el emulador suele ser muy lento :)</p>

<p><strong>Debe quedar algo así:</strong></p>

<p><img src="http://1.bp.blogspot.com/-lIKGAk40dis/UzMj8I1KvkI/AAAAAAAAAJA/_VeE9Tp-z_M/s1600/button_events_1.png" alt="enter image description here" /></p>

<p><strong>Y al presionar el botón debe aparecer esto:</strong></p>

<p><img src="http://3.bp.blogspot.com/-CxQOQQd5SOw/UzMj8cJauyI/AAAAAAAAAI4/kJegpZCGRGU/s1600/button_events_2.png" alt="enter image description here" /></p>

<p>Bien, eso es todo por ahora. En el próximo punto vamos a hacer que nuestra pantalla tenga más componentes, como <code>EditText</code> (algo así como los <code>JTextField</code> de <code>Swing</code>) y que lo que escribamos en ellos pase a otra pantalla para ser procesado.
Ahí, nos leemos. <strong>Recuerda seguirme en las redes sociales</strong>. Preguntas y comentarios a la orden, saludos!</p>
]]></content>
  </entry>
  
</feed>
